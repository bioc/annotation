<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Annotation}
-->




![](/images/icons/help.gif)Using Bioconductor for Annotation
============================================================

Bioconductor has extensive facilities for mapping between microarray
probe, gene, pathway, gene ontology, homology and other annotations. 

Bioconductor has built-in representations of GO, KEGG, vendor, and
other annotations, and can easily access NCBI, Biomart, UCSC, and
other sources.

* [Sample OrgDb Workflow](#sample-workflow-OrgDb)  
* [Sample ChipDb Workflow](#sample-workflow-ChipDb)  
* [Sample TxDb Workflow](#sample-workflow-TxDb)  
* [Sample OrganismDb Workflow](#sample-workflow-OrganismDb)  
* [Making an OrganismDb package](#Making-an-OrganismDb-package)  
* [Making full use of keys](#full-use-of-keys)  
* [Sample AnnotationHub Workflow](#sample-workflow-AnnotationHub)  
* [Using biomaRt](#Using-biomaRt)
* [BSgenome packages](#using-BSgenome)
* [Installation and Use](#install-and-use)
* [Exploring Package Content](#exploring-package-content)
* [Annotation Resources](#annotation-resources)



<h2 id="package-type">Package Types</h2> Bioconductor contains many
different types of annotation packages.  You can browse the currently
available types here
[here](http://www.bioconductor.org/packages/release/BiocViews.html#___PackageType)
by simply using the bioconductor web site.

On the web site you will see many different kinds of packages.  One of the largest categories are the many platform specific packages that contain annotation data about a particular microarray platform (ChipDb objects).  But there are also many org packages that contain gene centered data about an organism (OrgDb objects).   And there are even packages that contain genome centered data about an organisms transcriptome (TxDb objects) or genome (BSgenome objects).

This document will demonstrate some of the more typical use cases for most of the more popular kinds of annotation packages (and their associated objects).  

<img src="databaseTypes.png" width="50%">

The above diagram shows some of the major classes of object types that are supported in this project and diagrams how they are typically related to each other.  Later we will also cover a class of meta annotation object that can wrap access to several different kinds of related annotation objects into a single container (OrganismDb objects).  


<h2 id="sample-workflow-OrgDb">Sample OrgDb Workflow</h2>

The organism wide gene centered packages (OrgDb packages) each contain
gene centered data for an organism.  These packages are the primary place for storing data that can be directly associated with genes.  Lets take a closer look at the organism package for human:
```{r echo=FALSE}
suppressPackageStartupMessages(library(org.Hs.eg.db))
```

```{r}
library(org.Hs.eg.db)
```

Once loaded, each OrgDb object can be accessed using the following four methods:

To list the kinds of things that can be retrieved, use the columns method.
```{r}
columns(org.Hs.eg.db)
```

To list the kinds of things that can be used as keys we can use the
keytypes method
```{r}
keytypes(org.Hs.eg.db)
```

And to extract viable keys of a particular kind (keytype), we can use the keys method.
```{r}
head(keys(org.Hs.eg.db, keytype="ENTREZID"))
```

Since the keys method can tell us specific things that can be used as keys, here we will use it to extract a few ids to use for demonstrating the fourth method type.
```{r}
ids = head(keys(org.Hs.eg.db, keytype="ENTREZID"))
```


Once you have some ids that you want to look up data for, the select method allows you to map these ids as long as you use the columns argument to indicate what you need to know and the keytype argument to specify what kind of keys they are.
```{r}
select(org.Hs.eg.db, keys=ids, columns="SYMBOL", keytype="ENTREZID")
```

And since the columns argument can take a vector of valid columns, you can look up multiple things at once.
```{r}
select(org.Hs.eg.db, keys=ids, columns=c("GENENAME", "SYMBOL"), keytype="ENTREZID")
```


But where would we normally get the "ids" that we would pass in to the keys argument? Usually these kinds of ids come from the result of a data analysis.  Here I will load an experiment data package to provide us with an example data set to look at:

```{r}
library("parathyroidSE")
data(exonicParts)
exonicParts[1:3]
```

Now having just loaded this data set, I can extract the ensembl gene IDs contained in this object like this:
```{r}
ids = unlist(mcols(exonicParts)$gene_id)
head(ids)
```

From here I can look up gene symbols for these ids by using the select method like this.  Notice how I have to specify the correct (and different from before) keytype in order to extract these:
```{r}
res <- select(org.Hs.eg.db, keys=ids, columns="SYMBOL", keytype="ENSEMBL")
head(res)
```

And if I am careful to make sure that there were not any many to one relationships changing the size of the result data.frame, then I can even put these gene symbols back into the initial object:
```{r}
dim(res)[1] == length(exonicParts)
newMcols <- cbind(mcols(exonicParts), res[,2,drop=FALSE])
mcols(exonicParts) <- newMcols
exonicParts[1:3]
```


Of course we can look up many things other than just gene names and symbols.  For example, we could also extract the GO ids associated with the first id like this:

```{r}
id = ids[1]
res <- select(org.Hs.eg.db, keys=id, columns="GO", keytype="ENSEMBL")
head(res)
```

You may have noticed that the above request results in many rows for just one input id (and that a warning was issued about this).  Sometimes when you use select you may ask for columns that will result in select having to return multiple values for each key that you passed in.  This is caused by the structure of the underlying data.  This kind of data is sometimes said to have a many to one relationship because there are many things that can match to each key.  When this happens select() will return multiple rows for each key that you used as input because the return value for select is a data.frame object.  A warning is issued in this case because this behavior might not be what you were expecting.  If you request multiple many to one relationships at once, it will result in a multiplication of the returned rows as each row will represent a unique combination of the data that you asked for.  This is not recommended as you can very quickly generate a data.frame object that is both very large and simultaneously not very useful.  For best results, use select carefully, and avoid requesting more than one many to one value at any given time.

When making use of GO ids, you can also use the GO.db package to find the Terms associated with those GO ids.  The GO.db package will load a GOdb object that can be used in a manner similar to what we just saw with our OrgDb object for org.Hs.eg.db.  And we can use the same four methods that we just learned about (columns, keytypes, keys and select), to extract whatever data we need.

```{r}
library("GO.db")
head(res$GO)  ## shows what we are using as keys
head(select(GO.db, keys=res$GO, columns="TERM", keytype="GOID"))
```


<h3>Exercises for OrgDb objects.</h3>

Exercise 1: Look at the help page for the different columns and keytypes values with: help("SYMBOL").  Now use this information and what we just described to look up the entrez gene and chromosome for the gene symbol "MSX2".

Exercise 2: In the previous exercise we had to use gene symbols as
keys.  But in the past this kind of behavior has sometimes been
inadvisable because some gene symbols are used as the official symbol
for more than one gene.  To learn if this is still happening take
advantage of the fact that entrez gene ids are uniquely assigned, and
extract all of the gene symbols and their associated entrez gene ids
from the org.Hs.eg.db package. Then check the symbols for redundancy.

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>





<h2 id="sample-workflow-ChipDb">Sample ChipDb Workflow</h2>

The following illustrates a typical R / Bioconductor
session for a ChipDb package. It continues the
[differential expression](/help/workflows/oligo-arrays/) workflow,
taking a 'top table' of differentially expressed probesets and
discovering the genes probed, and the Gene Ontology pathways to which
they belong.

```{r echo=FALSE}
suppressPackageStartupMessages(library(hgu95av2.db))
```

First lets consider some typical probe Ids.  If you have done a
microarray analysis before you have probably already run into IDs like
this.  They are typically manufacturer assigned and normally only
relevant to a small number of chips.  Below I am just going to
demonstrate on 6 probe Ids from the u133 2.0 affymetrix platform.
```{r}
## Affymetrix U133 2.0 array IDs of interest; these might be
## obtained from
##
##   tbl <- topTable(efit, coef=2)
##   ids <- tbl[["ID"]]
##
## as part of a more extensive workflow.
ids <- c("39730_at", "1635_at", "1674_at", "40504_at", "40202_at")
```

Load libraries as sources of annotation

```{r}
library("hgu95av2.db")
```


And from here you can use the new ChipDb object in the same way that you learned to use an OrgDb object before.  The only real change is that the ChipDb object will also have data about how platform specific probes match to specific genes.  So for example:


```{r}
columns(hgu95av2.db)
keytypes(hgu95av2.db)
columns <- c("PFAM","SYMBOL")
select(hgu95av2.db, keys=ids, columns, keytype="PROBEID")
```


<h3>Exercises for ChipDb objects.</h3>

Exercise 3: Examine the gene symbols for both the hgu95av2.db and the
org.Hs.eg.db packages.  Which one has more gene symbols?  Which one
has more gene symbols that can be mapped to an entrez gene ID?  Which
object seems to contain more information?

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>





<h2 id="sample-workflow-TxDb">Sample TxDb Workflow</h2>

The genome centered TxDb packages support the same interface
as that ChipDb and the OrgDb packages.

```{r echo=FALSE}
suppressPackageStartupMessages(library(TxDb.Hsapiens.UCSC.hg19.knownGene))
```

```{r}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene ## done for convenience
keys <- head(keys(txdb, keytype="GENEID"), n=2)
columns <- c("TXNAME", "TXSTART","TXSTRAND")
select(txdb, keys, columns, keytype="GENEID")
```

But in addition to supporting the standard set of methods (select,
keytypes, keys and columns).  The TxDb objects also support
methods to retrieve the annotations as ranges.  These accessors break
down into two basic categories.  The most basic will return
annotations as GRanges objects.  Some examples of these are:
transcripts(), exons() and cds().

This for example will return all the transcripts as ranges:

```{r}
transcripts(txdb)
```

And this will return all the exons as ranges:
```{r}
exons(txdb)
```

But these operations will also support the extraction of extra
metadata.  All extra data will be inserted into the metadata slot of
the returned GRanges object.  So for example you could spice up your
call to transcripts by using the columns argument like this.

```{r}
transcripts(txdb, columns = c("tx_id","tx_name","gene_id"))
```


The 2nd kind of range accessor supported by TxDb objects are
the ones that return GRangesList objects.  Some examples of these are:
transcriptsBy(), exonsBy() or cdsBy().  These accessors just allow you
to return a GRangesList object that contains the desired ranges by
split up by some important feature type that is specified using the
"by" argument.  A typical case is to extract all the transcript ranges
known for all the genes.  You can do that like this:

```{r}
transcriptsBy(txdb, by="gene")
```

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>



<h3>Exercises for TxDb objects.</h3>

Exercise 4: Use the accessors for the
TxDb.Hsapiens.UCSC.hg19.knownGene package to retrieve the gene id,
transcript name and transcript chromosome for all the transcripts.  Do
this using both the select() method and also using the transcripts()
method.   What is the difference in the output?


Exercise 5: Load the TxDb.Athaliana.BioMart.plantsmart16 package. This
package is not from UCSC and it is based on plantsmart.  Now use
select or one of the range based accessors to look at the gene ids
from this TxDb object.  How tdo they compare to what you saw
in the TxDb.Hsapiens.UCSC.hg19.knownGene package?





<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>




<h2 id="sample-workflow-OrganismDb">Sample OrganismDb Workflow</h2>

What if you wanted to combine all the good stuff from the GO.db
package with what you find in the appropriate TxDb and OrgDb
packages for an organism?  Then you would want to use an OrganismDb
package.  An example of an OrganismDb package is the Homo.sapiens
package.  Like the OrgDb, ChipDb and TxDb packages, it
supports the use of select, keytypes, keys and columns.  

```{r echo=FALSE}
suppressPackageStartupMessages(library(Homo.sapiens))
```

```{r}
library(Homo.sapiens)
keys <- head(keys(Homo.sapiens, keytype="ENTREZID"), n=2)
columns <- c("SYMBOL","TXNAME")
select(Homo.sapiens, keys, columns, keytype="ENTREZID")
```

When an OrganismDb package knows about a relevant TxDb
package, it can also support the ranged accessors introduced with the
TxDb objects.

```{r}
transcripts(Homo.sapiens, columns=c("TXNAME","SYMBOL"))
```


<h2 id="Making-an-OrganismDb-package">Making an OrganismDb package</h2>

You might be surprised to learn that an OrganismDb package does not
itself contain very much information.  Instead, it "knows where to
find it", but referencing other packages that themselves implement a
select interface.  So to create an OrganismDb package, you really only
need to specify where the information needs to come from.  Configuring
an OrganismDb object is therefore pretty simple. You simply create a
special list object that describes which IDs from each package are the
same kind of IDs in other packages to be included, along with the
relevant package names.  So in the following example, the "GOID"
values from the GO.db package act as foreign keys for the "GO" values
in the org.Hs.eg.db package and so on.


```{r eval=FALSE}
gd <- list(join1 = c(GO.db="GOID", org.Hs.eg.db="GO"),
      	   join2 = c(org.Hs.eg.db="ENTREZID",
           TxDb.Hsapiens.UCSC.hg19.knownGene="GENEID"))

makeOrganismPackage(pkgname = "Homo.sapiens",
	            graphData = gd,
		    organism = "Homo sapiens",
		    version = "1.0.0",
		    maintainer = "Package Maintainer<maintainer@somewhere.org>",
		    author = "Some Body",
		    destDir = ".",
		    license = "Artistic-2.0")
```

In this way, you can create a custom OrganismDb package for any
organism of interest, providing that you have also have access to the
supporting packages.  There is a vignette that covers this topic in
more detail
[here](http://www.bioconductor.org/packages/release/bioc/vignettes/OrganismDbi/inst/doc/OrganismDbi.pdf).



<h3>Exercises for OrganismDb objects.</h3>

Exercise 6: Use the Homo.sapiens object to look up the gene symbol,
transcript start and chromosome using select().  Then do the same
thing using transcripts.  You might expect that this call to
transcripts will look the same as it did for the TxDb object,
but (temporarily) it will not.

Exercise 7: Look at the results from call the columns method on the
Homo.sapiens object and compare that to what happens when you call
columns on the org.Hs.eg.db object and then look at a call to columns on the
TxDb.Hsapiens.UCSC.hg19.knownGene object. What is the difference
between TXSTART and CHRLOC?  Which one do you think you should use for
transcripts or other genomic information?


<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>




<h2 id="full-use-of-keys">Making full use of keys</h2>
Lets look more closely at the keys method.  We have already talked
about how you can use it to do this:

```{r}
library(Homo.sapiens)
keys <- head(keys(Homo.sapiens, keytype="ENTREZID"), n=2)
```

And then you can use it with select to look up other kinds of
information.  But what if you only know partial information about the
keys you are looking up?  In Bioconductor 2.13 and higher there are
extra arguments for the keys method that you can make use of to find
keys that match certain criteria.  The most useful is probably the
pattern argument.  The pattern argument allows you to find out which
keys match a certain pattern.  So for example, you can look up entrez
gene IDs that start with a "2" like this:

```{r}
head(keys(Homo.sapiens, keytype="ENTREZID", pattern="^2"), n=6)
```
Or you could look up gene symbols that start with "MS":

```{r}
head(keys(Homo.sapiens, keytype="SYMBOL", pattern="^MS"), n=6)
```
If your string matching is too specific, you could also try to use
fuzzy matching by setting the fuzzy argument to TRUE:

```{r}
head(keys(Homo.sapiens, keytype="SYMBOL", pattern="^MS", fuzzy=TRUE), n=6)
```
 And if you want to match one one key and actually return another, then you can use the column argument to indicate which key you want to search for pattern on while using the keytype to indicate which kind of key you want returned.  So you could (for example) get back ensembl IDs where the symbol starts with "MS".

```{r}
keys <- head(keys(Homo.sapiens, keytype="ENSEMBL", pattern="^MS", column="SYMBOL"), n=6)
keys
select(Homo.sapiens, keys, "SYMBOL", keytype="ENSEMBL")
```


<h3>Exercises for OrganismDb objects.</h3>
Exercise 8: Use the Homo.sapiens object with the keys method to look
up the entrez gene IDs for all gene symbols that contain the letter
"X". 


<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>





<h2 id="sample-workflow-AnnotationHub">Sample AnnotationHub Workflow</h2>

So far we have been discussing annotations that are fairly well
established and that represent consensus findings from the scientific
community.  These kinds of annotations are usually curated at large
governmental institutions like NCBI or ensembl and for the most part
everyone basically agrees about what they mean and how to use them.

But sometimes the annotations that you need are not as well
established.  Sometimes (for example) we just need to compare our
results to the data from a recent large study such as the encode
project.  The AnnotationHub package is designed to be useful for
getting access to data like this.  AnnotationHub allows you to get
access to data from a range of different data reposotories, with the
caveat that the data objects in AnnotationHub have all been
pre-processed into appropriate R objects for you.

To make use of AnnotationHub, you need to load the package and then
create an AnnotationHub object.  Notice that unlike the other
packages, with AnnotationHub, you have to create an AnnotationHub
object when you 1st start up your R session.

```{r}
library(AnnotationHub)

ah = AnnotationHub()
```

Once you have done this, you can "find" any of the available resources
just by tab completing along a path like this.


```{r}
res <- ah$goldenpath.hg19.encodeDCC.wgEncodeUwTfbs.wgEncodeUwTfbsMcf7CtcfStdPkRep1.narrowPeak_0.0.1.RData

res
```

In the above example, AnnotationHub will retrieve, download and cache
locally the file that you tab-completed to, and then store the results
in "res".


Now you can see how many ways there are to currently complete that
path, by checking the length of the AnnotationHub object:

```{r}
length(ah)
```

The AnnotationHub is still a pretty new resource, and we already hav a
LOT of things in there!  How can we narrow this down?  Right now we
can use filters. By default, there are no filters applied, so calling
filters() on our AnnotationHub is just an empty list.

```{r}
filters(ah)
```

What things can be used as filters?  We can use the columns() method to find out.


```{r}
columns(ah)
```

What values can be used with these filters?  Here, the keys method will give us an answer.


```{r}
head(keys(ah, keytype="Species"))
```

So now we know what we need to apply a filter to our AnnotationHub.
The following filter will limit our AnnotationHub to just those
entries that correspond to cattle (Bos taurus).


```{r}
filters(ah) <- list(Species="Bos taurus")

length(ah)
```


We can also view  and filter our AnnotationHub object interactively 
by simply calling the display function on it


```{r eval=FALSE}
d <- display(ah)
```

We can then  filter the AnnotationHub 
object for "Homo sapiens" by either using the Global search field 
on the top right corner of the page or the in-column search field for 
"Species".


<img src="display.png" width="50%">


By default 1000 entries are displayed per page, we can change this using
the filter on the top of the page or navigate through different pages
using the page scrolling feature at the bottom of the page.


We can also select the rows of interest to us and send them back to 
the R session using 'Send Rows' button ; 
this sets a filter internally which filters the 
AnnotationHub object.


<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>

<h3>Exercises for AnnotationHub.</h3>

Exercise 9: Set the AnnotationHub filter to NULL to clear it out, and
then set ip up so that it is extracting data that originated with the
UCSC data provider and that is also limited to Homo sapiens and the
hg19 genome.


Exercise 10 Now that you have basically narrowed things down to the
hg19 annotations from UCSC genome browser, lets get one of these
annotations.  Now tab complete your way to the oreganno track and save
it into a local variable.  


<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


<h2 id="Using-biomaRt">Using biomaRt</h2>

Another valuable resource is the biomaRt package.  The biomaRt package
exposes a huge family of online annotation resources called marts.
Here is a brief run down of how to use it.  For the first step, load
the package and decide which "mart" you want to use, then use the
useMart() method to create a mart object

```{r}
library("biomaRt")
head(listMarts())
ensembl <- useMart("ensembl")
ensembl
```

Next you need to decide on a dataset.  This can also be specified in
the mart object that is created when you call the the useMart()
method.

```{r}
head(listDatasets(ensembl))
ensembl <- useMart("ensembl",dataset="hsapiens_gene_ensembl")
ensembl
```

Next we need to think about filters and values. In the biomaRt
package, filters are things that can be used with values to restrict
or choose what comes back.  So you might choose a filter of
"affy_hg_u133_plus_2" to go with specific values.  For example you
might choose c("202763_at","209310_s_at","207500_at") to go with the
filter "affy_hg_u133_plus_2".  Together these two things would request
things that matched those probeset IDs on the platform listed as the
filter.  There is an accessor for the kinds of filters that are
available from a given mart/dataset:


```{r}
head(listFilters(ensembl))
```


Also, you need to know about attributes.  Attributes here mean the things that you want returned.  So if you want to know the gene symbol or something like that.  You would list that as an attribute.  There are accessors to list the kinds of attributes you can look up too:


```{r}
head(listAttributes(ensembl))
```

Once you are done exploring and know what you want to extract, you can call the getBM method to get your data like this:


```{r}
affyids=c("202763_at","209310_s_at","207500_at")
getBM(attributes=c('affy_hg_u133_plus_2', 'entrezgene'), 
                    filters = 'affy_hg_u133_plus_2', 
                    values = affyids, mart = ensembl)
```

Now what would you do if you didn't know what the possible values are
for a given filter?  Well you could just request all the possible
values by not specifying the filter, and instead only specifying it as
an attribute like this:

```{r}
head(getBM(attributes='affy_hg_u133_plus_2', mart = ensembl))
```

Of course if you find the standard biomaRt methods difficult to work with, you can now also use the standard select methods here.  

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


<h3>Exercises for biomaRt.</h3>

Exercise 11: Pull down GO terms for entrez gene id "1" from human by
using the ensembl "hsapiens_gene_ensembl" dataset.


Exercise 12: Now compare the GO terms you just pulled down to the same
GO terms from the org.Hs.eg.db package (which you can now retrieve
using select()). What differences do you notice? Why do you suspect
that is?



<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>



<h2 id="using-BSgenome">BSgenome packages</h2>

There are many BSgenome packages in the repository too.  These packages contain sequence data for sequenced organisms.  You can load one of these packages just like this:

```{r}
library(BSgenome.Hsapiens.UCSC.hg19)
ls(2)
Hsapiens
```

The getSeq method is useful for extracting data from these pacakges. This method takes several arguments but the important ones are the 1st two.  The 1st argument specifies the BSgenome object to use and the second argument (names) specifies what data you want back out.  So for example, if you call it and give a character vector that names the seqnames for the object then you will get the sequences from those chromosomes as a DNAStringSet object.

```{r}
seqNms <- seqnames(Hsapiens)
head(seqNms)
getSeq(Hsapiens, seqNms[1:2])
```

Whereas if you give the a GRanges object for the 2nd argument, you can instead get a DNA StringSet that corresponds to those ranges.

```{r}
rngs <- GRanges(seqnames = c('chr1', 'chr4'), strand=c('+','-'),
                ranges = IRanges(start=c(100000,300000), 
                                 end=c(100023,300037)))
rngs
res <- getSeq(Hsapiens, rngs)
res
```

This can be a very powerful way to quickly get sequences of interest.  And for more useful tools the BSgenome package also has useful functions for finding a pattern in a string set etc.


<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>

<h2 id="install-and-use">Installation and Use</h2>

Follow [installation instructions](/install/) to start using these
packages.  To install the annotations associated with the Affymetrix
Human Genome U95 V 2.0, and with Gene Ontology, use

```{r eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite(c("hgu95av2.db", "GO.db"))
```

Package installation is required only once per R installation. View a
full list of available
[software](/packages/release/bioc/)
and 
[annotation](/packages/release/data/annotation/)
packages.

To use the `AnnotationDbi` and `GO.db` package, evaluate the commands

```{r eval=FALSE}
library(AnnotationDbi)
library(GO.db)
```

These commands are required once in each R session.

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>

<h2 id="exploring-package-content">Exploring Package Content</h2>

Packages have extensive help pages, and include vignettes highlighting
common use cases. The help pages and vignettes are available from
within R. After loading a package, use syntax like

    help(package="GO.db")
    ?select

to obtain an overview of help on the `GO.db` package, and the `select`
method.  The `AnnotationDbi` package is used by most `.db`
packages. View the vignettes in the `AnnotationDbi` package with

```{r eval=FALSE}
browseVignettes(package="AnnotationDbi")
```

To view vignettes (providing a more comprehensive introduction to
package functionality) in the `AnnotationDbi` package. Use

```{r eval=FALSE}
help.start()
```

To open a web page containing comprehensive help resources.

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>

<h2 id="annotation-resources">Annotation Resources</h2>

The following guides the user through key annotation packages.  Users
interested in how to create custom chip packages should see the
vignettes in the `AnnotationForge` package. There is additional
information in the `AnnotationDbi`, `OrganismDbi` and
`GenomicFeatures` packages for how to use some of the extra tools
provided. You can also refer to the [complete list of annotation
packages](/packages/release/BiocViews.html#___AnnotationData).

### Key Packages ###

* [AnnotationDbi](/packages/release/bioc/html/AnnotationDbi.html)
  Almost all annotations require the `AnnotationDbi` package. This
  package will be automatically installed for you if you install
  another ".db" annotation package using biocLite(). It contains the
  code to allow annotation mapping objects to be made and manipulated
  as well as code to use the select methods etc..
* [OrganismDbi](/packages/release/bioc/html/.html)
  OrganismDbi allows meta packages that enable the user to access
  resources from several different packages as if they were coming
  from one place.  So for example the Homo.sapiens package is enabled
  by OrganismDbi and allows the user to get access to GO.db, the
  associated organism package IDs and the related transcript data for
  the hg19 build of the human genome all as if it were contained in a
  single convenient object.
* [GenomicFeatures](/packages/release/bioc/html/.html)
  GenomicFeatures allows the existance of TxDb objects and
  allows convenient representation of ranges from Transcritomes.
  There are accessors for things like exons, transcripts as well as
  the select method for retrieving data from packages supported by
  GenomicFeatures.
* [AnnotationForge](/packages/release/bioc/html/.html)
  AnnotationForge documents and assists in the creation of some kinds
  of custom annotation packages. 
* [Category](/packages/release/bioc/html/Category.html)
  This is the base level package for dealing with annotation questions
  that involve categorical data.
* [GOstats](/packages/release/bioc/html/GOstats.html)
  This builds on what is found in Category so that you can do
  hypergeometric testing using the Gene Ontology found in the GO.db
  package.
* [annotate](/packages/release/bioc/html/annotate.html)
  This package contains many helpful tools for making use of
  annotations.
* [AnnotationHub](/packages/release/bioc/html/AnnotationHub.html)
  This package allows the user to create an AnnotationHub which
  downloads and caches useful annotation data as R objects.
* [biomaRt](/packages/release/bioc/html/biomaRt.html)
  This package is a great way to pull annotation data directly from
  web based annotation resources. Such data is extremely "current", so
  it is a good idea to save and locally manage the data that you pull
  down from biomaRt so that your code will be reproducible.
* [VariantAnnotation](/packages/release/bioc/html/VariantAnnotation.html)
  This package contains useful tools for managing genetic data and for      
  quickly assessing if a detected change is inside of a coding region 
  or not.


### Types of Annotation Packages ###

* Organism annotation packages contain all the gene based data for an entire
  organism. All Organism packages are named like this:
  org."Xx"."yy".db. Where "Xx" is the abbreviation for Genus and
  species. And "yy" is the source of the central ID that is used to
  tie all the data together. Some examples are:
  [org.Hs.eg.db](/packages/release/data/annotation/html/org.Hs.eg.db.html)
  which is for Homo sapiens and is based upon Entrez Gene IDs. And
  [org.At.tair.db](/packages/release/data/annotation/html/org.At.tair.db.html)
  which is for Arabidopsis thaliana and is based on the tair IDs.
* TransriptDb packages contain range and chromosome information for
  specific transcriptomes.  These are based on a particular genome
  build and are are the place to look for where a
  gene/transcripts/exon coordinate information is relative to a
  genome.  These are also named in a way that tells you about where
  the data came from and can be generated with functions contained in
  the GenomicFeatures package.
* OrganismDb packages are named for the species they represent (such
  as the Homo.sapiens package).  These packages contain references to
  other key annotations packages and can thus represent all the
  underlying data as if it were coming from one place.  So for
  example, the Homo.sapiens package can allow you to retrieve data
  about the ranges of a genes transcripts at the same time that you
  extract it's gene name because it represents both a the
  transcriptome and the relevant org package for Homo sapiens.  These
  can be generated using functions in the OrganismDbi package if you
  have specific packages that you want to link together.
* There are also packages for questions about general systems biology
  data. Some examples of this are:
  [KEGG.db](/packages/release/data/annotation/html/KEGG.db.html)
  for accessing data that pertains to Kyoto Encyclopedia of Genes and
  Genomes. [GO.db](/packages/release/data/annotation/html/GO.db.html) for
  accessing data that pertains to the Gene
  Ontology. [PFAM.db](/packages/release/data/annotation/html/PFAM.db.html)
  for accessing data that pertains to different protein family
  identifiers and how they relate to each other.
* Chip annotation packages are for accessing only the data from one
  specific platform at a time. These packages are named like this:
  "platformName".db.  Where "platformName" is the name of the chip
  platform that these packages refer to. And example would be
  [hgu95av2.db](/packages/release/data/annotation/html/hgu95av2.db.html)
  which is for the hgu95av2 platform from Affymetrix.
* Inparanoid homology packages are for accessing inparanoid
  data. hom."Xx".inp.db Where "Xx" is the abbreviation for Genus and
  species. An example is
  [hom.Hs.inp.db](/packages/release/data/annotation/html/hom.Hs.inp.db.html)
  which contains inparanoid based mapping data between genes for Homo
  sapiens and 35 other organisms.</li>
* .db0 packages are for making custom platform specific
  packages. These packages are named like this: "name".db0. Where
  "name" is the name of the organism being represented. A list of the
  available .db0 packages can be obtained by calling
  available.db0Pkgs(). There is one of these for each supported
  organism. An example would be
  [human.db0](/packages/release/data/annotation/html/human.db0.html). Users
  should not need these installed unless they plan to make custom chip
  packages according the guidelines in the SQLForge vignette that is
  included with the `AnnotationDbi` package.  These packages must be
  upgraded before you attempt to update your custom chip packages as
  they contain the source databases needed by the SQLForge code.
* For relevant Affymetrix platforms you may also want the cdf and
  probe packages for that platform.  These packages are named using
  the following convention: "platformName"cdf and
  "platformName"probe. Where "platformName" is the name of the chip
  platform that these packages refer to.

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>





### Answers for exercises: ###

<h3>Exercise 1:</h3>

```{r}
keys <- "MSX2"
columns <- c("ENTREZID", "CHR")
select(org.Hs.eg.db, keys, columns, keytype="SYMBOL")
```



<h3>Exercise 2:</h3>

```{r}
## 1st get all the gene symbols
orgSymbols <- keys(org.Hs.eg.db, keytype="SYMBOL")
## and then use that to get all gene symbols matched to all entrez gene IDs
egr <- select(org.Hs.eg.db, keys=orgSymbols, "ENTREZID", "SYMBOL")
length(egr$ENTREZID)
length(unique(egr$ENTREZID))
## VS:
length(egr$SYMBOL)
length(unique(egr$SYMBOL))
## So lets trap these symbols that are redundant and look more closely...
redund <- egr$SYMBOL
badSymbols <- redund[duplicated(redund)]
select(org.Hs.eg.db, badSymbols, "ENTREZID", "SYMBOL")
```



<h3>Exercise 3:</h3>

Initially you might expect that hgu95av2.db will have less information
in it.  After all, it's an old Affymetrix platform that was developed
before we even had a very complete human genome. So you might try
something like this:
```{r}
chipSymbols <- keys(hgu95av2.db, keytype="SYMBOL")
orgSymbols <- keys(org.Hs.eg.db, keytype="SYMBOL")
length(orgSymbols)
length(chipSymbols)
```
And you might feel confused and so you might try this:
```{r}
dim(select(org.Hs.eg.db,orgSymbols, "ENTREZID", "SYMBOL"))
dim(select(hgu95av2.db,chipSymbols, "ENTREZID", "SYMBOL")) 
```
And you might also have noticed this:
```{r}
length(columns(org.Hs.eg.db)) < length(columns(hgu95av2.db))
```
Well the answer you have in front of you is actually correct.  There
actually is more information available in the hgu95av2.db object than
in the org.Hs.eg.db object.  This is because even though the
hgu95av2.db object technically can only have probes for some genes in
the genome, it still (behind the scenes) retrieves data about gene
names etc. from the org.Hs.eg.db package.  So it effectively has
access to all the data from the org package PLUS the probes for that
platform and what those map to.  So that means that for there will be
information about many gene symbols that don't actually match up to
any probeset Ids. And that is what we see if we use gene symbols to
look up the probes Ids.
```{r}
head(select(hgu95av2.db,chipSymbols, "PROBEID", "SYMBOL"))
```



<h3>Exercise 4:</h3>

So to retrieve this information using select you need to do it like this:

```{r}
res1 <- select(TxDb.Hsapiens.UCSC.hg19.knownGene, 
               keys(TxDb.Hsapiens.UCSC.hg19.knownGene, keytype="TXID"),
       	       columns=c("GENEID","TXNAME","TXCHROM"), keytype="TXID")

head(res1)
```

And to do it using transcripts you do it like this:
```{r}
res2 <- transcripts(TxDb.Hsapiens.UCSC.hg19.knownGene, 
                    columns = c("gene_id","tx_name")) 
head(res2)
```

Notice that in the 2nd case we don't have to ask for the chromosome,
as transcripts() returns a GRanges object, so the chromosome will
automatically be returned as part of the object.



<h3>Exercise 5:</h3>

```{r}
library(TxDb.Athaliana.BioMart.plantsmart22)
res <- transcripts(TxDb.Athaliana.BioMart.plantsmart16, columns = c("gene_id")) 
```
You will notice that the gene ids for this package are TAIR locus IDs
and are NOT entrez gene IDs like what you saw in the
TxDb.Hsapiens.UCSC.hg19.knownGene package.  It's important to always
pay attention to the kind of gene id is being used by the TxDb
you are looking at.



<h3>Exercise 6:</h3>

```{r eval=FALSE}
library(Homo.sapiens)
keys <- keys(Homo.sapiens, keytype="TXID")
res1 <- select(Homo.sapiens, 
               keys= keys,
       	       columns=c("SYMBOL","TXSTART","TXCHROM"), keytype="TXID")

head(res1)
```

And to do it using transcripts you do it like this:
```{r}
library(Homo.sapiens)
res2 <- transcripts(Homo.sapiens, columns="SYMBOL") 
head(res2)
```


<h3>Exercise 7:</h3>

```{r}
columns(Homo.sapiens)
columns(org.Hs.eg.db)
columns(TxDb.Hsapiens.UCSC.hg19.knownGene)
## You might also want to look at this:
transcripts(Homo.sapiens, columns=c("SYMBOL","CHRLOC"))
```
The key difference is that the TXSTART refers to the start of a
transcript and originates in the TxDb object from the
TxDb.Hsapiens.UCSC.hg19.knownGene package, while the CHRLOC refers to
the same thing but originates in the OrgDb object from the
org.Hs.eg.db package.  The point of origin is significant because the
TxDb object represents a transcriptome from UCSC and the OrgDb
is primarily gene centric data that originates at NCBI.  The upshot is
that CHRLOC will not have as many regions represented as TXSTART,
since there has to be an official gene for there to even be a record.
The CHRLOC data is also locked in for org.Hs.eg.db as data for hg19,
whereas you can swap in a different TxDb object to match the
genome you are using to make it hg18 etc.  For these reasons, we
strongly recommend using TXSTART instead of CHRLOC.  Howeverm CHRLOC
still remains in the org packages for historical reasons.


<h3>Exercise 8</h3>
To find the keys that match, make use of the pattern and column arguments.
```{r}
library(Homo.sapiens)
xk = head(keys(Homo.sapiens, keytype="ENTREZID", pattern="X", column="SYMBOL"))
xk
```
select verifies the results
```{r}
select(Homo.sapiens, xk, "SYMBOL", "ENTREZID")
```


<h3>Exercise 9:</h3>

The 1st thing you need to do is look at the keytypes:
```{r}
keytypes(ah)
```

Then you want to look at possible values for DataProvider and for Genome.
```{r}
keys(ah, keytype="DataProvider")
head(keys(ah, keytype="Genome"))
```

```{r}
filters(ah) <- NULL
filters(ah) <- list(Species="Homo sapiens", 
                    DataProvider="hgdownload.cse.ucsc.edu",
		    Genome="hg19")
length(ah)
```


<h3>Exercise 10:</h3>

This pulls down the oreganno annotations.  Which are described on the
UCSC site thusly: "This track displays literature-curated regulatory
regions, transcription factor binding sites, and regulatory
polymorphisms from ORegAnno (Open Regulatory Annotation). For more
detailed information on a particular regulatory element, follow the
link to ORegAnno from the details page."

```{r}
res <- ah$goldenpath.hg19.database.oreganno_0.0.1.RData
```



<h3>Exercise 11:</h3>

```{r}
library("biomaRt")
ensembl <- useMart("ensembl",dataset="hsapiens_gene_ensembl")
ids=c("1")
getBM(attributes=c('go_id', 'entrezgene'), 
		    filters = 'entrezgene',
                    values = ids, mart = ensembl)

```



<h3>Exercise 12:</h3>

```{r}
library(org.Hs.eg.db)
ids=c("1")
select(org.Hs.eg.db, keys=ids, columns="GO", keytype="ENTREZID")
```

When this exercise was written, there was a different number of GO
terms returned from biomaRt than from org.Hs.eg.db.  This may not
always be true in the future though as both of these resources are
updated.  It is expected however that this web service, (which is
updated continuously) will fall in and out of sync with the
org.Hs.eg.db package (which is updated twice a year).  This is an
important difference as each approach has different advantages and
disadvantages.  The advantage to updating continuously is that you
always have the very latest annotations which are frequently different
for something like GO terms.  The advantage to using a package is that
the results are frozen to a release of Bioconductor. And this can help
you to get the same answers that you get today (reproducibility), a
few years from now.


<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


<h2 id="sessionInfo">SessionInfo</h2>

```{r}
sessionInfo()
```

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>
